\documentclass{article}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{geometry}
\geometry{hmargin=2.5cm,vmargin=3cm}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\date{\today}
\author{Tarik Atlaoui \\ Nicolas Peugnet \\ Kimmeng Ly \\ Max Eliet}

\begin{document}


\begin{titlepage}
	\enlargethispage{2cm}
	\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
	\center
	\textsc{\LARGE
	Pre-rapport du PSAR 
	} \\[1cm]
	\HRule \\[0.4cm]
	{ \huge \bfseries API générique pour le développement d'applications réparties \\[0.15cm] }
	\HRule \\[4cm]
	\large{Tarik Atlaoui \\[3mm] Nicolas Peugnet \\[3mm] Kimmeng Ly \\[3mm] Max Eliet} \\[3cm]
	09 Mars 2020 \\[3cm]
	\hfill \includegraphics[width=5cm]{logoSU.jpg}
\end{titlepage}

	\newpage
	\pagenumbering{arabic}
		\section{Introduction}
			\subsection{Les applications réparties : qu'est-ce ?}
			 \subsection{Les difficultés à programmer une application répartie}

		\section{Méthode de développement}
			\subsection{API réelle : avantages/inconvénients + exemple API(MPI ou autre)}
			\subsection{API simulation à évenements discrets : qu'est-ce ? + avantages/inconvénients + exemple(PeerSim ou autre)}
				\large{Qu'entend-on par \textit{simulation à événements discrets}? C'est une simulation dont le temps évolue seulement lorsqu'un événement survient sur un noeud, et donc de même l'état du système ne peut être modifié qu'à ces moments là.
\newline \indent On distingue donc deux entités : les noeuds, et les événements qui sont caractérisés par une date de délivrance, un noeud destinataire, et des données.
\newline \indent Les principaux avantages d'un tel type de simulation sont : son déterminisme et donc une capacité à reproduire des bugs, et une charge de calcul réduite aux événements qu'on décide de simuler. Toutefois, il faut savoir trouver un équilibre entre une simulation trop simpliste et une simulation trop précise ralentie par trop d'événements.
\newline \indent Dans notre cas, nous nous sommes dirigés vers PeerSim comme simulateur à événements discrets, car il est codé en Java et possède une API relativement simple d'utilisation. }
			\newpage
			\subsection{Aperçu de l'implémentation d'un anneau avec les deux API}
				{\bfseries Implémentation en MPI}
				\begin{lstlisting}
public class RingMpi {
	public static void main(String[] args) {
			MPI.Init(args);
			Comm comm = MPI.COMM_WORLD;
			int size = comm.getSize();
			int rank = comm.getRank();
			int neighbour = (rank + 1) % size;
			int hellotag = 1;
			Integer msg = 0;
			Status status;
			if (rank == 0) {
				comm.send(msg, 0, MPI.INT, neighbour, hellotag);
				status = comm.recv(msg, 0, MPI.INT, MPI.ANY_SOURCE, hellotag);
			} else {
				status = comm.recv(msg, 0, MPI.INT, MPI.ANY_SOURCE, hellotag);
				comm.send(msg, 0, MPI.INT, neighbour, hellotag);
			}
			System.out.println(rank + " Received hello from " + status.getSource());
			MPI.Finalize();
		}
	}
}
				\end{lstlisting}
				{\bfseries Implémentation en PeerSim}
				\begin{lstlisting}
public class HelloProtocol implements EDProtocol {
	//Declarations d'attributs et fonctions retirees pour la clarte du code
	...
	//Un noeud souhaite faire sa diffusion du message a son voisin
	public void direVoisin(Node host) {
		Transport tr= (Transport) host.getProtocol(pid_transport);
		Node dest=Network.get((int) ((host.getID()+1)%Network.size()));
		Message mess= new Message(host.getID(),(host.getID()+1)%Network.size(),my_pid, new ArrayList<>(myList));
		tr.send(host, dest, mess, my_pid);

		deja_dit_voisin=true;
	}

	//Traitement a effectuer lorsqu'on recoit un HelloMessage
	private void receiveHelloMessage(Node host, HelloMessage mess) {
		System.out.println("Noeud "+ host.getID() + " : a recu Hello de "+mess.getIdsrc()+ " sa liste = "+mess.getInfo());
		if(!deja_dit_voisin) {
			direVoisin(host);
		}
	}
				\end{lstlisting}
		\section{Motivation et objectif global}
			\subsection{API générique : avantages, modèle de programmation(ici événementiel)}
				Le but de notre projet est de produire une API générique sur un modèle de programmation événementielle afin de faciliter le développement de futures applications réparties, en permettant de s'abstraire du support d'éxécution au niveau du code métier. \par
Pouvoir éxécuter le même code métier aussi bien sur une plateforme réelle que sur un simulateur permet au développeur d'une application répartie de passer de l'un à l'autre, sans risquer d'en  modifier son comportement en adaptant le code. \newline \indent Il peut donc profiter des avantages d'un simulateur, comme la vision globale du système et le déterminisme des séquences d'éxécution  sans crainte d'y introduire des erreurs. \par
 
			\newpage
			\subsection{Aperçu de l'implémentation d'un anneau avec l'API générique}
				\begin{lstlisting}
public class ExampleNodeProcess extends NodeProcess {

	public static class ExampleMessage extends Message{
	
		private static final long serialVersionUID = 1L;
		private String s;
		public ExampleMessage(int src, int dest, String s) {
			super(src, dest);
			this.s = s;
		}

		public String getS() {
			return s;
		}

	}

	@Override
	public void processMessage(Message message) {
		int host = infra.getId();
		System.out.println("" + host + " Received hello from "  + message.getIdsrc());
		if (host != 0) {
			int dest = (host + 1) % infra.size();
			infra.send(new ExampleMessage(infra.getId(), dest, "hello"));
		}
		infra.exit();
	}

	@Override
	public void start() {
		if (infra.getId() == 0) {
			infra.send(new ExampleMessage(infra.getId(), 1, "hello"));
		}
	}
}

public class BasicTest {

	@Test
	public void MpiExample() {
		Ppi.main(new String[] { ExampleNodeProcess.class.getName(), MpiRunner.class.getName() });
		assertTrue(true);
	}

	@Test
	public void PeersimExample() {
		Ppi.main(new String[] { ExampleNodeProcess.class.getName(), PeerSimRunner.class.getName() });
		assertTrue(true);
	}
}
				\end{lstlisting}
		\section{Les étapes de réalisation}
			\subsection{Définition API générique}
			\subsection{Définition des primitives offertes et explication}
			\subsection{Implantation vers MPI}
			\subsection{Implantation vers PeerSim}
			\subsection{API pour un scenario}
			\subsection{Rédaction du rapport}

		\section{Plan de validation}
			\subsection{Comment montrer que cela fonctionne bien, tests unitaires, respect du cahier des charges}
		\section{Planning des tâches}
			\subsection{Une deadline pour chaque tâche dans un ordre chronologique}
\end{document}
