\BOOKMARK [1][-]{section.1}{Introduction}{}% 1
\BOOKMARK [2][-]{subsection.1.1}{Les applications r\351parties}{section.1}% 2
\BOOKMARK [2][-]{subsection.1.2}{Les difficult\351s \340 programmer une application r\351partie}{section.1}% 3
\BOOKMARK [1][-]{section.2}{M\351thode de d\351veloppement}{}% 4
\BOOKMARK [2][-]{subsection.2.1}{API r\351elle : avantages/inconv\351nients et exemple \(MPI ou autre\)}{section.2}% 5
\BOOKMARK [2][-]{subsection.2.2}{API simulation \340 \351venements discrets :avantages/inconv\351nients et exemple\(PeerSim ou autre\)}{section.2}% 6
\BOOKMARK [2][-]{subsection.2.3}{Aper\347u de l'impl\351mentation d'un anneau avec les deux API}{section.2}% 7
\BOOKMARK [1][-]{section.3}{Motivation et objectif global}{}% 8
\BOOKMARK [2][-]{subsection.3.1}{API g\351n\351rique : avantages, mod\350le de programmation\(ici \351v\351nementiel\)}{section.3}% 9
\BOOKMARK [2][-]{subsection.3.2}{Aper\347u de l'impl\351mentation d'un anneau avec l'API g\351n\351rique}{section.3}% 10
\BOOKMARK [1][-]{section.4}{Les \351tapes de r\351alisation}{}% 11
\BOOKMARK [2][-]{subsection.4.1}{D\351finition API g\351n\351rique}{section.4}% 12
\BOOKMARK [2][-]{subsection.4.2}{D\351finitions des primitives offertes et explication}{section.4}% 13
\BOOKMARK [2][-]{subsection.4.3}{Implantation vers MPI}{section.4}% 14
\BOOKMARK [2][-]{subsection.4.4}{Implantation vers PeerSim}{section.4}% 15
\BOOKMARK [2][-]{subsection.4.5}{Fonction wait dans l'infrastructure}{section.4}% 16
\BOOKMARK [2][-]{subsection.4.6}{Tests plus pouss\351s des invariants}{section.4}% 17
\BOOKMARK [2][-]{subsection.4.7}{API pour un scenario}{section.4}% 18
\BOOKMARK [2][-]{subsection.4.8}{R\351partition des t\342ches}{section.4}% 19
\BOOKMARK [1][-]{section.5}{Prise en main de notre API}{}% 20
\BOOKMARK [2][-]{subsection.5.1}{Programmer un algorithme}{section.5}% 21
\BOOKMARK [3][-]{subsubsection.5.1.1}{Etendre le classe NodeProcess}{subsection.5.1}% 22
\BOOKMARK [3][-]{subsubsection.5.1.2}{Cr\351er des classes de message}{subsection.5.1}% 23
\BOOKMARK [3][-]{subsubsection.5.1.3}{D\351finir des gestionnaires de messages}{subsection.5.1}% 24
\BOOKMARK [3][-]{subsubsection.5.1.4}{M\351thodes \340 dispositions}{subsection.5.1}% 25
\BOOKMARK [2][-]{subsection.5.2}{Lancer Ppi}{section.5}% 26
\BOOKMARK [3][-]{subsubsection.5.2.1}{Depuis un shell}{subsection.5.2}% 27
\BOOKMARK [3][-]{subsubsection.5.2.2}{Depuis un programme Java}{subsection.5.2}% 28
\BOOKMARK [2][-]{subsection.5.3}{D\351crire un sc\351nario}{section.5}% 29
\BOOKMARK [3][-]{subsubsection.5.3.1}{Introduction}{subsection.5.3}% 30
\BOOKMARK [3][-]{subsubsection.5.3.2}{Exemple de sc\351nario}{subsection.5.3}% 31
\BOOKMARK [3][-]{subsubsection.5.3.3}{D\351tails}{subsection.5.3}% 32
\BOOKMARK [2][-]{subsection.5.4}{Comment \351crire son propre adapter pour un autre support}{section.5}% 33
\BOOKMARK [1][-]{section.6}{Plan de validation}{}% 34
\BOOKMARK [2][-]{subsection.6.1}{Tests de validation}{section.6}% 35
\BOOKMARK [2][-]{subsection.6.2}{D\351monstration}{section.6}% 36
\BOOKMARK [1][-]{section.7}{Conclusion}{}% 37
\BOOKMARK [2][-]{subsection.7.1}{Rappel des objectifs et axes principaux de travail}{section.7}% 38
\BOOKMARK [2][-]{subsection.7.2}{Axes d'am\351lioration possibles et ouverture}{section.7}% 39
