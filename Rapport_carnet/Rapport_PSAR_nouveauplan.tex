\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{geometry}
\usepackage{array}
\usepackage{hyperref}
\geometry{hmargin=2.5cm,vmargin=3cm}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\hyphenation{GitHub}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\date{\today}
\author{Tarik Atlaoui \\ Nicolas Peugnet \\ Kimmeng Ly \\ Max Eliet}

\begin{document}


\begin{titlepage}
	\enlargethispage{2cm}
	\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
	\center
	\textsc{\LARGE
	Rapport PSAR 
	} \\[1cm]
	\HRule \\[0.4cm]
	{ \huge \bfseries API générique pour le développement d'applications réparties \\[0.15cm] }
	\HRule \\[4cm]
	\large{Tarik Atlaoui \\[3mm] Nicolas Peugnet \\[3mm] Kimmeng Ly \\[3mm] Max Eliet} \\[3cm]
	08 Juin 2020 \\[3cm]
	\large{Encadré par Jonathan Lejeune} \hfill \includegraphics[width=5cm]{logoSU.jpg}
\end{titlepage}

	\newpage
	\pagenumbering{arabic}
	\tableofcontents
	\newpage


		\section{Introduction et motivations}

			\subsection{Les applications réparties}
			Avant de commencer, il est important de définir ce qu’est une application répartie. Dans notre cas, nous pouvons voir une application répartie comme un ensemble d’entités logicielles, de composants qui peuvent être développés dans différents langages de programmation, s’exécutant sur plusieurs sites et qui sont reliés entre eux par une interface ou un réseau de communication.

			\subsection{Les difficultés à programmer une application répartie}
			 Aujourd’hui la programmation d’applications réparties est devenue une réalité du monde informatique, cette forme de programmation permet d'augmenter la disponibilité des applications et de diminuer leur temps d'exécution. Cependant, réaliser une application répartie reste une tâche délicate. En effet, nous devons prendre en compte la maintenabilité et la réutilisabilité des programmes. De plus, les accès concurrents peuvent créer des erreurs et des sources d'incohérence. C’est pourquoi il est très important de montrer que ces programmes fonctionnent bien avec des tests unitaires tout en respectant le cahier des charges.


			\subsection{Méthodes de développement d'applications réparties existantes}

				Nous allons donc nous focaliser sur deux API servant au développement d'applications réparties : Message Passing Interface en tant qu'API pour une plateforme réelle, et Peersim en tant qu'API pour un simulateur à événements discrets, qui ont servi de base à notre projet.

				\subsubsection{Une API pour plateforme réelle : \textit{MPI}}
					L'API de MPI est avant tout une norme pour le passage de messages entre différents ordinateurs ou au sein d'un même ordinateur.
					Elle est énormément utilisée pour la communication dans des architectures distribuées, et donc adaptée sur de nombreuses architectures et ce de manière optimale, c'est pourquoi notre choix s'est porté sur MPI en tant qu'API pour une plateforme réelle.
					Cependant les tests et le debug sur celle-ci restent difficiles dû a l'impossibilité d'avoir un contrôle sur les évenements qui apparaissent, c'est donc pour parer à ces problèmes que l'on souhaite utiliser des simulateurs, comme par exemple Peersim, pour tester nos applications.
				
				
				\subsubsection{Une API de simulation à événements discrets : \textit{Peersim}}
					Qu'entend-on par \textit{simulation à événements discrets}? C'est une simulation dont le temps évolue seulement lorsqu'un événement survient sur un noeud, et donc de même l'état du système ne peut être modifié qu'à ces moments là.

					On distingue donc deux entités : les noeuds, et les événements qui sont caractérisés par une date de délivrance, un noeud destinataire, et des données.

					Les principaux avantages d'un tel type de simulation sont : son déterminisme et donc une capacité à reproduire des bugs, et une charge de calcul réduite aux événements qu'on décide de simuler. Toutefois, il faut savoir trouver un équilibre entre une simulation trop simpliste et une simulation trop précise ralentie par trop d'événements.

					Dans notre cas, nous nous sommes dirigés vers PeerSim comme simulateur à événements discrets, car il est codé en Java et possède une API relativement simple d'utilisation.

					PeerSim est utilisé pour créer des nœuds et simuler une architecture pair-à-pair en générant des protocoles et des événements qui sont définis par l'utilisateur. Une éxécution est toujours ce qui permet d'accélérer le débug d'une application répartie avant son déploiement ou de reproduire une séquence d'événements qui a provoqué un bug sur une application déja existante.

			
			\newpage
			\subsection{Premier aperçu de ces deux API}
			\large{Nous allons donc commencer par vous montrer les différences et similitudes qui existent entre deux implémentations d'un anneau, dont les noeuds se communiquent circulairement un entier, en commençant par le noeud d'identifiant 0. }

			\subsubsection{Exemple d'un anneau implémenté avec une API de plateforme réelle : MPI}
			\large{Dans cet exemple, nous pouvons observer plusieurs méthodes indispensables fournies par MPI, comme le déploiement par MPI.Init, l'émission et la réception de message par send et rcv, et la fin d'un noeud par MPI.Finalize. Nous allons le comparer à son équivalent en Peersim pour y trouver de multiples points communs.}
			\begin{lstlisting}
public class RingMpi {

	public static void main(String[] args) {
			MPI.Init(args);
			Comm comm = MPI.COMM_WORLD;
			int size = comm.getSize();
			int rank = comm.getRank();
			int neighbour = (rank + 1) % size;
			int hellotag = 1;
			Integer msg = 0;
           		Status status;
            
			if (rank == 0) {
				comm.send(msg, 0, MPI.INT, neighbour, hellotag);
				status = comm.recv(msg, 0, MPI.INT, MPI.ANY_SOURCE, hellotag);
			} else {
				status = comm.recv(msg, 0, MPI.INT, MPI.ANY_SOURCE, hellotag);
				comm.send(msg, 0, MPI.INT, neighbour, hellotag);
            }
			System.out.println("Noeud "+ rank + " : a recu "+ msg +" de "+status.getSource());
			MPI.Finalize();
		}
	}
}
                	\end{lstlisting}
			
			\newpage
			\subsubsection{Exemple d'un anneau implémenté avec une API de simulation : Peersim}
				Dans ce second exemple, nous pouvons observer certaines méthodes ayant leur équivalent en MPI, comme celle d'initialisation, la méthode processEvent qui effectue l'aiguillage des messages, et la méthode receiveRingMessage qui est effectuée lors de la réception d'un message. Il y a aussi des méthodes qui sont indispensables au fonctionnement de Peersim mais absentes dans MPI, comme la méthode clone.
				\begin{lstlisting}

public class RingProtocol implements EDProtocol {

	private static final String PAR_TRANSPORT="transport";
	private final int pid_transport;

	private final int my_pid; // identifiant du protocole
	private int myInt; 		// entier propre a chaque noeud
	private boolean deja_dit_voisin; // indique si message deja envoye

	public RingProtocol(String prefix) {

		System.out.println("prefix= "+prefix);
		String tmp[]=prefix.split("\\.");
		my_pid=Configuration.lookupPid(tmp[tmp.length-1]);
		pid_transport=Configuration.getPid(prefix+"."+PAR_TRANSPORT);
		deja_dit_voisin=false;
		myInt=0;
	}

	public Object clone() {
		RingProtocol ap= null;
		try {
			ap=(RingProtocol) super.clone();
			ap.myInt=this.myInt;
		}catch(CloneNotSupportedException e) {} // NEVER HAPPENS
		return ap;
	}

	//Lance l'anneau depuis le noeud d'ID 0
	public void initialisation(Node host) {
		if(host.getID()==0) {
			direVoisin(host);
		}
	}

	//La methode de l'interface EDProtocol de Peersim a implementer
	@Override
	public void processEvent(Node host, int pid, Object event) {
		// TODO Auto-generated method stub
		if(pid!=my_pid) throw new IllegalArgumentException("Incoherence sur l'id de protocole");
		if(event instanceof RingMessage) {
			receiveRingMessage(host,(RingMessage) event);
		}else {
			throw new IllegalArgumentException("Evenement inconnu pour ce protocole");
		}
	}

	//Traitement a effectuer lorsqu'on recoit un RingMessage
	private void receiveRingMessage(Node host, RingMessage mess) {
		System.out.println("Noeud "+ host.getID() + " : a recu "+mess.getInfo() +" de "+mess.getIdsrc());
		myInt=mess.getInfo();
		if(!deja_dit_voisin) {
			direVoisin(host);
		}
	}

	//Un noeud souhaite faire sa diffusion du message a son voisin
	private void direVoisin(Node host) {
		Transport tr= (Transport) host.getProtocol(pid_transport);
		Node dest=Network.get((int) ((host.getID()+1)%Network.size()));
		Message mess= new RingMessage(host.getID(),(host.getID()+1)%Network.size(),my_pid,myInt+1);
		tr.send(host, dest, mess, my_pid);

		deja_dit_voisin=true;
	}
}
               		\end{lstlisting}

		
			\subsection{Création d'une API générique}
				Le but de notre projet est de produire une API générique sur un modèle de programmation événementielle afin de faciliter le développement de futures applications réparties, en permettant de s'abstraire du support d'éxécution au niveau du code métier. \par
Pouvoir éxécuter le même code métier aussi bien sur une plateforme réelle que sur un simulateur permet au développeur d'une application répartie de passer de l'un à l'autre, sans risquer d'en  modifier son comportement en adaptant le code. \newline Il peut donc profiter des avantages d'un simulateur, comme la vision globale du système et le déterminisme des séquences d'éxécution  sans crainte d'y introduire de nouveaux bugs. \par
 
			\newpage
			\subsection{Aperçu de l'implémentation d'un anneau avec notre API générique}
				Voici un exemple du même anneau que celui des deux exemples précédents, on y retrouve une méthode init() correspondant aux méthodes MPI.Init() et initialisation(),
une méthode processRingMessage, annotée par @MessageHandler, contenant le code à effectuer lors de la réception d'un message. Quant à l'aiguillage, il est ici transparent puisqu'on l'effectue dans la méthode parente NodeProcess.
				\begin{lstlisting}
public class RingExample extends NodeProcess {

	public static class RingMessage extends Message {
	
		private static final long serialVersionUID = 1L;
		private int content;
		public RingMessage(int src, int dest, int c) {
			super(src, dest);
			this.content = c;
		}

		public int getContent() {
			return content;
		}

	}

	@MessageHandler
	public void processRingMessage(RingMessage message) {
		int host = infra.getId();
		System.out.println("Noeud "+ host + " a recu " + message.getContent() + " de " + message.getIdsrc());
		if (host != 0) {
			int dest = (host + 1) % infra.size();
			infra.send(new RingMessage(infra.getId(), dest, message.getContent()+1));
		}
		infra.exit();
	}

	@Override
	public void init(String[] args) {
		if (infra.getId() == 0) {
			infra.send(new RingMessage(infra.getId(), 1, 0));
		}
	}

}			
				\end{lstlisting}




		
                
				\newpage
				\section{Présentation de l'API générique}
				L'idée pricipale est de produire une API générique permettant d'abstraire le support d'exécution au niveau du code métier, c'est-à-dire produire une couche logicielle afin de pouvoir exécuter de façon transparente le même code sur un simulateur (\verb|PeerSim|) et sur une infrastructure réelle (\verb|MPI|).					
				\subsection{Schéma UML des classes génériques}
					\vspace{2mm}
					\hspace*{-1cm} \includegraphics[width=22cm]{uml/generique.png}
					
					\vspace{8mm}
					Nous avons commencé par définir une classe abstraite \verb|NodeProcess| qui représente un processus à exécuter et une autre classe abstraite \verb|Infrastructure| qui contient toutes les méthodes que nous devrons implanter pour les deux API (\verb|MPI| et \verb|PeerSim|), cette classe abstraite permet également d'abstraire l'infrastructure sur laquelle \verb|NodeProcess| est exécutée.
					\newline
					\newline
					Le lancement de \verb|MPI| et de \verb|PeerSim| est complètement différent, c’est pourquoi il est primordial que les deux lancements soient unifiés pour permettre un développement plus rapide et sûr. 
					\newline
					Pour remédier à cette situation, notre solution consiste à créer une interface \verb|Runner| qui permet d’instancier les exécutions des deux API avec les mêmes arguments. Il suffit donc d’instancier \verb|MPIRunner| et/ou \verb|PeerSimRunner| avec en argument le nom de la classe qui hérite de \verb|NodeProcess|, le nom de la classe du \verb|Runner| , et, si on le souhaite, le nombre de processus ainsi qu’un scénario, puis finalement d'appeler la classe \verb|Ppi| (notre classe \emph{main}) en lui fournissant les arguments décrits précédemment.
		
					\newpage
					\subsection{Primitives offertes}
					Les primitives mises à disposition correspondent à l'ensemble des méthodes publiques de la classe abstraite \verb|Infrastructure| dont une instance est accessible via la propriété \emph{infra}.
					\newline
					Voici la liste des primitives offertes par notre API générique : 
					\newline
					
					\begin{lstlisting}
						void send(Message message)
					\end{lstlisting}
					Envoyer un message à un noeud.
					
					\begin{lstlisting}
						int getId()
					\end{lstlisting}
					Récupérer l'id du processus courant.
		
					\begin{lstlisting}
						abstract void exit()
					\end{lstlisting}
					Arrêter l'exécution du processus courant.
		
					\begin{lstlisting}
						abstract int size()
					\end{lstlisting}
					Retourne le nombre de noeud dans l'infrastructure.
		
					\begin{lstlisting}
						int deploy()
					\end{lstlisting}
					Déployer le noeud courant.
					\begin{lstlisting}
						int undeploy()
					\end{lstlisting}
					Annuler le déploiement du noeud courant.
		
					\begin{lstlisting}
						void serialThreadRun(Runnable method)
					\end{lstlisting}
					Lancer un thread qui sera exécuter en série et dans lequel on peut utiliser la primitive \emph{wait}.
		
					\begin{lstlisting}
						void wait(BooleanSupplier condition)
					\end{lstlisting}
					Attendre tant que la condition passée en argument n'est pas évaluée à vraie. Il est recommander de passer une lambda retournant un booléen en paramètre.
		
					\subsection{La fonctionnalité de scénario}
					Notre API permettra aussi de définir des actions ou pannes sur un nœud donné à l'aide d'un scénario prédéfini qui va permettre de les exécuter sur les deux infrastructures sous-jacentes,
					afin de l'utiliser, il suffit de définir un fichier JSON et d'ajouter le chemin vers ce dernier (nous verrons cela plus en détail en annexe).
		
		

				\section{Présentation des deux Adapters}
				
				\subsection{Adapter Peersim}
				L'implantation de notre API du côté de \verb|PeerSim| consiste principalement à effectuer un Adapter avec l'API déjà existante de \verb|PeerSim|. Il fallait donc comprendre le fonctionnement des classes de \verb|PeerSim| nécessaires pour faire le lien entre les deux API,  
				et également adapter certaines de nos classes pour \verb|PeerSim|, par exemple rendre \verb|NodeProcess| clonable. 
				\newline
				Ainsi, la classe \verb|PeerSiminfrastructure| fait le lien entre notre API générique et l'API de \verb|PeerSim|.
					\subsubsection{Schéma UML Peersim}
					\hspace*{-1.3cm} \includegraphics[width=17cm]{uml/peersim1.png}

					\hspace*{-3.2cm} \includegraphics[width=20cm]{uml/peersim2.png}

				\subsubsection{Les difficultés pour implanter l'adapter : multithreading et wait}
				
				\subsubsection{Scenario en Peersim}
				\vspace{5mm}
				\hspace*{5cm} \includegraphics[width=60mm]{uml/scenPuml.png}
				
				\vspace{5mm}
				Peersim ayant déjà une fonctionnalité qui permet de définir un ou plusieurs évènements qui peuvent être définis avec un délai de livraison donné à l'aide de la class \verb|EDSimulator|,
				l'implantation de notre fonctionnalité de scénario vers peersim repose entièrement sur elle.
				En effet la class \verb|EDSimulator| a une fonction \verb|add|
				\begin{lstlisting}
				static void add(long delay, java.lang.Object event, Node node, int pid)
				\end{lstlisting}
				qui permet de programmer un événement qui va être délivré sur un nœud donné. 
				\newline
				Nous avons utilisé celle-ci afin de délivrer les évènements définis dans le fichier JSON, au début de l'application si on choisit le runner de \verb|PeersimRunner| , celui-ci va 
				les lire et les ajouter dans la file des évènements de Peersim.
Pour représenter un événement de l'application, nous avons défini donc une interface \verb|AppEvent|,
				Lorsqu'un le nœud reçoit un tel événement, il exécute la méthode run de l'interface dont les instructions correspondront à l'évènement, par exemple la méthode \verb|run()| la class \verb|SchedEvent| 
				correspondra à l'appel d'une fonction définie par l'utilisateur et  \verb|OnEvent|/\verb|OffEvent| à la fin et début d'une panne.
		
			\newpage
			\subsection{Adapter MPI}
			Dans le cas de \verb|MPI|, pour implanter l'Adapter, nous avons commencé par implanter un algorithme simple (un anneau). Puis, une fois que nous avons compris l'essentiel de \verb|MPI|, nous avons étendu la classe \verb|Infrastructure|, ainsi la classe \verb|MpiInfrastructure| nous permet de communiquer avec l'API \verb|MPI|. 
			Nous avons, cependant, dû ajouter une boucle afin d'adapter le fonctionnement de \verb|MPI| à celui de \verb|PeerSim|.
				\subsubsection{Schéma UML MPI}
				\vspace{1mm}
				\hspace*{-2.1cm} \includegraphics[width=19.5cm]{uml/mpi1.png}

				\hspace*{-2.3cm} \includegraphics[width=20cm]{uml/mpi2.png}
				\subsubsection{Les difficultés pour implanter l'adapter : passer au modèle événementiel}
				\subsubsection{Scenario en MPI}
				\vspace{5mm}
				\hspace*{4cm} \includegraphics[width=80mm]{uml/scenMPIuml.png}
				
				\vspace{5mm}
				Pour l'implémentation sous MPI nous avons utilisé la classe \verb|Timer| pour planifier un évenement sur un noeud donné.
				\newline
				Nous avions commencé par implanter un processus supplémentaire qui ce lançait à chaque demande de simulation et qui se chargeait d'envoyer des 
				messages applicatifs distingués par l'interface \verb|AppMessage| , ainsi chaque processus qui recoit un message étendant cette interface , créer la classe 
				qui étend la classe \verb|TimerTask| et l'insère dans son timer afin qu'elle soit éxecutée en temps voulu.
				\newline
				Cependant cette implémentation c'est révélée être plus compliqueée à mettre en place car elle devait être faite à la construction des processus et fut donc abondonnée.
				\newline
				A la place, dès l'utilisation de l'option scénario avec le le MpiRunner tous les processus reçoivent le chemin vers le fichier JSON, le lisent, et créent les classes correspondantes aux événements. 
		
				
		
		\section{Plan de validation}
			%TODO
			%Comment montrer que cela fonctionne bien, tests unitaires, respect du cahier des charges, l'algo Naimi Trehel nous permet  de tester l'ensemble des fonctionnalités (+ test deploy/undeploy?)
			\subsection{Tests de validation}
			Pour chaque fonctionnalité ajoutée nous ajoutons un test et nous nous assurons que les tests précédents fonctionnent toujours.
			\newline
			La classe BasicTest est la toute première classe de tests que nous avons implémenté, elle s'assure que les fonctionnalités de base de notre API
			send/receive et le format de description de scénario restent fonctionnels malgré les nouveaux ajouts.

			Plusieurs algorithmes distribués seront implantés et testé unitairement dont celui de l'anneau et au moins une exclusion mutuelle.
		
			%TODO
			\subsection{Scénario de validation le jour de la soutenance}
		
		\newpage
		\section{Conclusion}
			%TODO
			%Piqûre de rappel de ce qu'on disait au début pour montrer qu'on a réussi à le faire 
			\subsection{Objectifs et axes principaux de travail}
			L'objectif premier de ce projet était de réaliser une API permettant de faciliter le test et le déploiement d'applications réparties, puis dans une seconde partie avoir une 
			fonctionnalité permettant de décrire une suite d'évènements. 
			\newline
			Les deux objectifs ont été atteint et notre API permet bien de réaliser ces deux contraintes,
			cependant vu la complexité des API Perrsim et MPI sous-jacent notre API est loin d'être capable d'exploiter la totalité des fonctionnalités proposées par ces deux platformes.
			\subsection{Axes d'amélioration possibles et ouverture}
			Comme dit précédemment, il existe beaucoup d'axes d'amélioration possible pour notre API, nous avons jugé bon d'en énumérer certaines qui à défaut de temps n'ont pas pu être implémentées.

			\begin{description}
				\item[Changer le Scheduler TimerTask par SchedularConfigurer ou @Scheduled.] \hfill \\ TimerTask ne s'est pas révélée être la solution la plus adéquate à notre utilisation et le changer pourrait augmenter la fiabilité de l'exécution du scénario coté Mpi
				\item[Abstraire la quasi totalité du fichier de configuration de Peersim] \hfill \\ une bonne partie du fichier de configuration de Peersim est réécrite par notre application cependant il serait intéressant que l'utilisateur puisse ajouter des configurations sur notre api et les transmettre à Peersim.
			  \end{description}
		

			  \newpage


		\section{Annexe : répartition des tâches}
			\hspace*{-0.8cm}\begin{tabular}{|c|c|c|}
				\hline
				Tâche & Date d'échéance & Fait par\\[1mm]
				\hline
		  		Se familiariser avec MPI et Peersim & 17/02 & Tous\\[1mm]
				\hline
				Proposer une API générique & 24/02 & Tous\\[1mm]
				\hline
				Implanter l'API pour MPI & 02/03 & Nicolas et Tarik \\[1mm]
				\hline
				Implanter l'API pour PeerSim & 02/03 & Kimmeng et Max \\[1mm]
				\hline
				Créer une classe abstraite Message & 09/03 & Tous\\[1mm]
				\hline
				Unifier le lancement de l'application & 09/03 & Nicolas\\[1mm]
				\hline
				Rédiger le carnet de bord & 16/03 & Tous\\[1mm]
				\hline
				Rédiger le pre-rapport & 23/03 & Tous\\[1mm]
				\hline 
				Implanter l'aiguillage automatique des messages & 23/03 & Tous\\[1mm]
				\hline
				Ajouter la fonctionnalité de description de scenario & 30/03 & Tarik\\[1mm]
				\hline
				Ajouter des fonctionnalités de wait/notify & 25/05 & Nicolas et Kimmeng\\[1mm]
				\hline
				Ajouter des tests plus poussés sur les invariants & 25/05 & Tarik et Max\\[1mm]
				\hline 
				Rédiger le rapport final & 08/06 & Tous\\[1mm]
				\hline
				Soutenance finale & 12/06 & Tous\\[1mm]
				\hline
			\end{tabular}


		\section{Annexe : Prise en main de notre API}

		\subsection{Programmer un algorithme}
		Pour programmer un algorithme à l'aide de Ppi il faut créer une classe qui étend la classe abstraite \lstinline{NodeProcess}. Par la suite l'ensemble des méthodes disponible seront accessibles par l'intermédiaire de la propriété \lstinline{infra}.

		\subsubsection{Etendre le classe \lstinline{NodeProcess}}
		La classe abstraite \lstinline{NodeProcess} contient une methode abstraite \lstinline{init}
		qu'il est nécessaire de redéfinir dans votre classe :
		\begin{lstlisting}
public void init(String[] args)
		\end{lstlisting}
		Cette méthode permet d'initialiser chaque processus à l'aide des arguments qui lui sont
		passés en paramètre. Elle peut être utile comme point de départ d'un algorithme où bien
		simplement pour le paramètrer.
		L'étape suivante sera de créer les différentes classes de message nécessaires au bon
		fonctionnement de votre algorithme.

		\subsubsection{Créer des classes de message}
		Chaque classe de message doit étendre la classe \lstinline{Message} et l'ensemble de son
		contenu doit être \lstinline{Serializable}. De cette manière il sera possible de les envoyer
		via Ppi et de les réceptionner à l'aide de gestionnaires de messages. Il est conseillé de
		créer une classe par type de message applicatif et ainsi de créer un gestionnaire par type
		de message.

		\subsubsection{Définir des gestionnaires de messages}
		Pour définir un gestionnaire de message, rien de plus simple. Ajoutez à votre classe
		héritant de \lstinline{NodeProcess} une fonction pernant en paramètre un objet d'une des
		classes de message que vous venez de définir et ajoutez-y l'annotation
		\lstinline{@MessageHandler} :
		\begin{lstlisting}
@MessageHandler
public void handlerTestMessage(TestMessage msg) {}
		\end{lstlisting}

		Il ne doit y avoir qu'un seul gestionnaire de message par classe de message, sinon le
		premier trouvé sera choisi par Ppi.
		\newline
		\newline
		\newline
		\textbf{NB:} Les méthodes mises à disposition pour l'utilisateur sont décrites dans la partie 2.2.
		Elles sont également consultable en ligne au format javadoc\footnote{\href{https://atlaoui.github.io/ParallelProgramingInterface/org/sar/ppi/Infrastructure.html}{https://atlaoui.github.io/ParallelProgramingInterface/org/sar/ppi/Infrastructure.html}}


		\newpage
		\subsection{Lancer Ppi}
		Un \lstinline{.jar} executable est téléchargeable pour chaque version dans la section \textit{releases}
		de GitHub\footnote{\href{https://github.com/Atlaoui/ParallelProgramingInterface/releases/}{https://github.com/Atlaoui/ParallelProgramingInterface/releases/}}
		ainsi qu'à chaque build sur la branche \lstinline{master} dans les artefacts du
		build\footnote{\href{https://github.com/Atlaoui/ParallelProgramingInterface/actions?query=workflow\%3Abuild+branch\%3Amaster}{https://github.com/Atlaoui/ParallelProgramingInterface/actions?query=workflow\%3Abuild+branch\%3Amaster}}.
		Ce \lstinline{.jar} permettra de compiler vos classes pour ensuite pouvoir les éxécuter.
		\begin{lstlisting}
javac -cp ppi.jar ExampleNodeProcess
		\end{lstlisting}

		\subsubsection{Depuis un shell}
		\noindent\begin{minipage}{\linewidth}
		Ppi dispose d'une interface en ligne de commande dont voici la page d'aide :
		\begin{lstlisting}
Usage: ppi [-hV] [--np=<number>] [-s=<path>] <process-class> <runner-class>
            [<args>...]
       <process-class>     Fully qualified name of the class to use as process
       <runner-class>      Fully qualified name of the class to use as runner
       [<args>...]         Args to pass to the processes
   -h, --help              Display a help message
       --np=<number>       Number of processus in the network
                                Default: 4
   -s, --scenario=<path>   Path to the scenario file
   -V, --version           Print version info
		\end{lstlisting}
		\end{minipage} 
		Et voici un exemple d'utilisation du \lstinline{.jar} executable. Il n'est pas nécessaires
		d'ajouter la classe du processus à exécuter si elle se trouve dans le répertoire courant
		car elle sera dynamiquement chargée :
		\begin{lstlisting}
java -jar ppi.jar ExampleNodeProcess org.sar.ppi.peersim.PeerSimRunner --np=4
		\end{lstlisting}

		\subsubsection{Depuis un programme Java}
		Afin de simplifier l'usage depuis un programme java un ensemble de fonctions
		\lstinline{main} de plus haut niveau que le \lstinline{main} standard a été ajouté. Il est
		composé de la fonction suivante ainsi que de plusieurs déclinaisons de cette fonction
		ommettant chacune un certain nombre de paramètres optionnels :
		\begin{lstlisting}
public static void main(
	Class<? extends NodeProcess> pClass,
	Runner runner,
	String[] args,
	int nbProcs,
	File scenario
) throws PpiException
		\end{lstlisting}
		Dans ce cas d'utilisation il suffit d'exécuter votre classe à l'aide de la commande java en
		ajoutant le \lstinline{.jar} au classpath :
		\begin{lstlisting}
java -cp .:ppi.jar ExampleNodeProcess
		\end{lstlisting}
		\newpage
		\subsection{Décrire un scénario}
		\subsubsection{Introduction}
		La fonctionnalité de description de scénario permet de programmer des événements qui se
		déclencheront au cours de l'éxécution du programme. Un scénario peut être décrit à l'aide
		d'un fichier \lstinline{JSON} contenant les événements et la date à laquelle ils devront
		être appelés, en unités de temps Ppi dont la durée est dépendante de l'infrastructure.

		Sachant que MPI travaille sur des processus distincts et que le temps de transmission des
		messages est inconnu, on ne garantit pas l'exactitude des dates de déclenchement des
		événements.
		\bigskip

			Les événements appellent des fonctions présentes dans votre classe héritant de
			\lstinline{NodeProcess} et il est possible de leur passer des arguments comme on peut le
			voir dans l'exemple suivant.
			\subsubsection{Exemple de scénario}
			\begin{lstlisting}
{
	"undeploy": [
		{
			"node": 0,
			"start": 100
		}
	],
	"events": [
		{
			"args": [
				{ "val": "MonArgument1", "type": "String" },
				{ "val": 4, "type": "Integer" }
			],
			"FunctionName": "End",
			"Node": 1,
			"Delay": 900
		},
		{
			"args": [],
			"FunctionName": "doSomething",
			"Node": 2,
			"Delay": 300
		}
	],
	"deploy": [
		{
			"node": 0,
			"start": 10000
		}
	]
}
			\end{lstlisting}
			\subsubsection{Détails}
			Les tableaux Json \lstinline{"undeploy"}, \lstinline{"deploy"} et \lstinline{"events"} contiennent
			les listes des différents appels demandés.
			Chacun contient une liste d'événements, par exemple \lstinline{"undeploy"} est une liste
			d'objet qui définissent \lstinline{"node"}, le noeud concerné et \lstinline{"start"}, la
			date à laquelle le noeud arrêtera de répondre aux messages.
			De la même manière \lstinline{"deploy"} réactive le noeud. Ces listes permettent à elles
			deux de simuler une panne.
			\bigskip

			L'objet \lstinline{"events"} représente une liste d'appel de fonctions utilisateur.
			L'élément \lstinline{"args"} des objets qu'elle contient désigne les arguments qui
			devront être passés à la fonction. Il faudra donc spécifier le type de chaque arguments
			ainsi que sa valeur.

			Notons que les types des arguments acceptés sont les types de base de java.
			Enfin la clé \lstinline{"FunctionName"} représente le nom de la fonction à appeler.
			\bigskip

			Pour aider la construction du fichier de configuration nous proposons les primitives de la class ProtocolTools suivante:
			\newline
			Pour construire un appel de fonction
			\begin{lstlisting}
				public static JSONObject eventBuilder(String funcName , int node, long delay, List<Object> args);
			\end{lstlisting}
			Pour construire un évenement deploy ou undeploy 
			\newline
			(dépendra du nom de l'objet qui le contiendra)
			\begin{lstlisting}
				public static JSONObject StateBuilder(int node, long start_at);
			\end{lstlisting}

			Enfin, pour lancer l'exécution du scénario, il faut juste ajouter le nombre de processus et le chemin vers le fichier Json au runneur souhaité.
		\newpage		
		\subsection{Comment écrire son propre adapter pour un autre support}

		
\end{document}
